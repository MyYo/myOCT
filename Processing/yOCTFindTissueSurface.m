function [surfacePosition,x,y] = yOCTFindTissueSurface(varargin)
% This function processes OCT scan data to identify tissue surface from the
% OCT image.
% USAGE:
%   [surfacePosition, x, y] = yOCTFindTissueSurface(logMeanAbs, dimensions, isVisualize)
% INPUTS:
%   logMeanAbs, dimensions - data structures generated by yOCTProcessTiledScan.
%       Converted to log scale
%   isVisualize - set to true to generate image heatmap visualization
%       figure. Default is false.
% OUTPUTS:
%   - surfacePosition- 2D matrix. dimensions are (y,x). What
%       height is image surface (measured from the top of the OCT scan).
%       Physical dimensions of surfacePosition are the same as dimensions.z.values
%   - x,y are the x,y positions that corresponds to surfacePosition(y,x).
%       Units are the same as dimensions.x.units


%% Parse inputs
p = inputParser;
addRequired(p,'logMeanAbs');
addRequired(p,'dimensions');
addParameter(p,'isVisualize',false)

parse(p,varargin{:});
in = p.Results;
logMeanAbs = in.logMeanAbs;
dim = in.dimensions;
isVisualize = in.isVisualize;


%% Identify tissue surface
% Retrieve the Dimensions
[z_size, x_size, y_size] = size(logMeanAbs);

% Create a matrix to store the Surface Depth for each (x, y) coordinate
surface_depth = zeros(x_size, y_size);

% Define Detection Parameters
z_size_threshold = 800;    % Threshold to determine the starting depth based on image height
high_z_start = 350;        % Starting depth for images with a large Z dimension
low_z_start = 1;           % Starting pixel for images with a small Z dimension
base_confirmations_required = 12;  % Initial consecutive pixels required to confirm surface
intensity_threshold = 2;   % Threshold for pixel intensity to consider as potential surface

% Adjust the start depth based on z_size
if z_size > z_size_threshold
    start_depth = high_z_start;
else
    start_depth = low_z_start;
end

% Main Loop - For each Y slice, analyze the data to find the surface height
for y = 1:y_size
    current_slice = logMeanAbs(:, :, y);
    surface_column = NaN(x_size, 1); % Initialize column for storing surface data

    for x = 1:x_size % Iterate over each X position within the slice
        found = false;  % Initialize flag to track if surface is found
        % Option to decrease confirmations needed if surface is not found
        
        for confirmations_required = base_confirmations_required:-1:11 % Adjustable decrease
            if found
                break;  % Exit early if surface is found
            end

            for z = start_depth:z_size
                if current_slice(z, x) >= intensity_threshold % Check if pixel intensity is above threshold

                    % Confirm surface if a sufficient number of consecutive pixels meet the criteria
                    if (z + confirmations_required <= z_size) && all(current_slice(z+1:z+confirmations_required, x) > 0)
                        surface_column(x) = z;  % Record the surface depth
                        found = true;  % Update flag
                        break; % Stop scanning as surface is confirmed
                    end
                end
            end
        end
    end

    surface_depth(:, y) = surface_column;  % Store the detected surface depths
end

% Configure the Gaussian Kernel Smoothing
sigma = 1.5;  % Deviation for the Gaussian kernel
kernel_size = ceil(sigma * 3) * 2 + 1;  % Determine kernel size based on sigma
gaussian_kernel = fspecial('gaussian', [kernel_size, kernel_size], sigma);  % Create Gaussian kernel

% Preprocessing Before Smoothing
surface_depth(isnan(surface_depth)) = 0;  % Replace NaN values with zeros to prepare for smoothing
smoothed_surface_depth = conv2(surface_depth, gaussian_kernel, 'same');  % Apply Gaussian filter to smooth the surface depth map

% Normalize the Smoothed Data
normalizing_kernel = conv2(surface_depth ~= 0, gaussian_kernel, 'same');  % Create a normalization matrix from non-zero entries
smoothed_surface_depth = smoothed_surface_depth ./ normalizing_kernel;  % Normalize to account for initial zeros used for NaNs
smoothed_surface_depth(normalizing_kernel == 0) = NaN;  % Restore NaN values where no original data existed
smoothed_surface_depth = round(smoothed_surface_depth);  % Round smoothed values to the nearest integer for uniform depth representation

% Assign z, x, y, coordinates
z = dim.z.values(:); x = dim.x.values(:); y = dim.y.values(:);

% Convert Depth found from Pixels to Units in dim.x.units like microns or mm
surface_depth_pixels = smoothed_surface_depth.'; % Transpose for consistent global orientation system
unit_per_pixel = abs(z(2) - z(1)); % Calculate Z unit per pixel ratio
surfacePosition = surface_depth_pixels * unit_per_pixel; % Get Surface Depth in Units


%% Generate Heatmap of Surface Height for user visualization
if isVisualize
    figure;
    imagesc(x, y, surfacePosition);
    colormap(flipud(jet));
    colorbar;
    set(gca, 'YDir', 'normal');
    title(['Surface position in ', dim.x.units, ' (View from the top)']);
    xlabel(['X-axis (', dim.x.units, ')']); 
    ylabel(['Y-axis (', dim.x.units, ')']); 
end
