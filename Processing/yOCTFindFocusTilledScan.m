function zFocusPix = yOCTFindFocusTilledScan(varargin)
% Context about the scan: When using higher magnification lens (10x or 40x)
% in OCT, wecannot have all depths (z) of the image in focus at the same
% time. For this reason, yOCTScanTile implements z-stacking. In z-stacking,
% translation stage moves the sample up&down to move the focus position in
% the tissue. There is a subtle point here and that is the position of the
% focus within the image of the OCT doesn't move, it is the tissue that
% moves while the focus stays constant.
%
% Context about the sample: We usually scan tissue with gel on top. Before
% the scan, the user places the tissue-gel interface at the focus position
% and start the scan. This means that z-stack image for z=0 has the focus
% at the gel-tissue interface. The scanner then scans some images in the
% gel (above tissue), and lower within the tissue.
%
% This funciton takes a folder generated by yOCTScanTile and finds the
% position of the focus using these two steps
% Step #1: Go to the z-stack for z=0, find the brightest pixel - this is an
% initial guess for where the tissue-gel interface is
% Step #2: Go to the z-stack for z<0, in theory we should be in the gel,
% and very easy to find the focus here
% Step #3: Let user refine as needed.
%
%USAGE:
%    zFocusPix = yOCTLoadScan(yOCTScanTileOutputFolderPath, [,parameter1,...]);
%INPUTS:
%   - yOCTScanTileOutputFolderPath - Folder in local computer or at s3://
% LIST OF OPTIONAL PARAMETERS AND VALUES
% Parameter                  Default    Information & Values
% 'reconstructConfig'        {}         Optional parameters for yOCTLoadInterfFromFile and yOCTInterfToScanCpx. E.g. 'dispersionQuadraticTerm'
% 'verbose'                  false      More information.
% 'manualRefinment'          true       Set to false to skip step #3
%
%OUTPUTS:
%   - zFocusPix - zDepth (in pixels) of the focus position in the scan. In
%                 case of tild scan.

%% Parse Inputs from varargin and load certain fields from json

p = inputParser;
addRequired(p,'yOCTScanTileOutputFolderPath');

addParameter(p,'reconstructConfig',{});
addParameter(p,'verbose',false);
addParameter(p,'manualRefinment',true); 

parse(p,varargin{:});
in = p.Results;
yOCTScanTileOutputFolderPath = in.yOCTScanTileOutputFolderPath;
verbose = in.verbose;

%% Get configuration data need
scanInfo = awsReadJSON([yOCTScanTileOutputFolderPath '/ScanInfo.json']);
[~, dim] = ...
    yOCTTileScanGetDimOfOneTile(yOCTScanTileOutputFolderPath, 'um');

%% Find which volume is closest to tissue-gel interface, which volume has gel only, and how many ySlices to load (so we can average)

% Find the volume for step #1, where focus is at tissue-gel interface
[~,volumeIndex_Step1] = min(abs(scanInfo.zDepths-0));
volumePath_Step1 = [yOCTScanTileOutputFolderPath '/' scanInfo.octFolders{volumeIndex_Step1}];

% Find volume in the gel
% If we have multiple volumes in the gel, don't pick the top most, pick one
% below
volumeIndex_Step2 = min(2,volumeIndex_Step1-1); 
volumePath_Step2 = [yOCTScanTileOutputFolderPath '/' scanInfo.octFolders{volumeIndex_Step2}];

% Pick which slices to load
yToLoad = unique(dim.y.index(...
    round(linspace(1,length(dim.y.index),5)) ...
    ));

%% Step #1, find the position with maximum intensity
if (verbose)
    disp('Step #1, initial guess. Find focus position by locating tissue - gel interface');
end

%Load some data
[meanAbs,dim] = yOCTProcessScan([{volumePath_Step1, ...
            {'meanAbs'}, ... 
            'n', scanInfo.tissueRefractiveIndex, ...
            'YFramesToProcess',yToLoad, ...
            'runProcessScanInParallel', false, ...
            } in.reconstructConfig]);
        
%Find tissue position by maximum intensity
if (verbose)
    figure(1);
end
tissueZi = zeros(size(yToLoad)); %Tissue depth for each scan
for i=1:length(tissueZi)
    im = squeeze(meanAbs(:,:,i));
    
    %Find maximum
    medScan = median(im,2);
    
    % It is unlikely that the focus will be too close to the top of the OCT
    % picture because when z-stacking is performed, the OCT signal will "wrap
    % around" causing blure.
    medScan(1:round(end/3)) = NaN;
    
    % Find the brightest pixel
    tissueZi(i) = find(medScan == max(medScan),1,'first');
    
    %Plot    
    if (i<=4 && verbose)
        subplot(2,2,i);
        imagesc(dim.x.values,dim.z.values,log(im))
        colormap gray
        hold on;
        fd =  dim.z.values(tissueZi(i));
        plot(dim.x.values([1 end]),fd*[1 1],'--');
        hold off;
        title(sprintf('y=%.2f',dim.y.values(i)));
        xlabel(['x [' dim.x.units ']'])
        ylabel(['z [' dim.z.units ']'])
        pause(0.1)
    end
end

focusZPixel_Step1 = round(median(tissueZi)); % pixel of part #1

%% Step #2, refine using the gel
if (verbose)
    disp('Step #2, refine using the gel');
end

%Load some data
[meanAbs,dim] = yOCTProcessScan([{volumePath_Step2, ...
            {'meanAbs'}, ... 
            'n', scanInfo.tissueRefractiveIndex, ...
            'YFramesToProcess',yToLoad, ...
            'runProcessScanInParallel', false, ...
            } in.reconstructConfig]);
        
% Average and smooth
m = squeeze(mean(median(meanAbs,2),3)); % Median over x, average over y
m = imgaussfilt(m,4); %Apply Gaussian filtering

% Find peaks, closest to first guess
[~,p] = findpeaks(m);
[~,i] = min(abs(p - focusZPixel_Step1));
focusZPixel_Step2 = round(p(i));

%% Show Our result
if (verbose || in.manualRefinment)
    figure(4)
    
    subplot(1,4,4);
    m = mean(meanAbs,[2,3]);
    scaleM = mean(m(focusZPixel_Step2+(-20:20)));
    scaleM = scaleM*[0.5 2];
    plot(scaleM,dim.z.values(focusZPixel_Step1)*[1 1],'--');
    hold on;
    plot(scaleM,dim.z.values(focusZPixel_Step2)*[1 1],'--');
    plot(m,dim.z.values,'k');
    hold off;
    xlim(scaleM);
    grid on;
    axis ij;
    title('Average Intensity');
    
    subplot(1,4,[1 3])
    imagesc(dim.x.values,dim.z.values,squeeze(log(mean(meanAbs,3))))
    colormap gray
    hold on;
    plot(dim.x.values([1 end]),dim.z.values(focusZPixel_Step1)*[1 1],'--');
    plot(dim.x.values([1 end]),dim.z.values(focusZPixel_Step2)*[1 1],'--');
    hold off;
    xlabel(['x [' dim.x.units ']'])
    ylabel(['z [' dim.z.units ']'])
    title('Focus Position');
    legend('First Guess','Updated Guess');
    fprintf('Initial guess: %.d[pix]\n',focusZPixel_Step1);
    fprintf('Updated guess: %.d[pix]\n',focusZPixel_Step2);
    caxis([-5 6]);
end

%% Step #3 Manual refinement
if ~in.manualRefinment
    zFocusPix = focusZPixel_Step2;
    return; % Skip manual refinement
end

if (verbose)
    disp('Step #3, Manual refinement');
end

%Manual mode, ask user to refine
title('Click on the image where the focus is');
[~,z] = ginput(1); %Get z index of the focus
[~,focusZPixel_Step3] = min(abs(z-dim.z.values));
focusZPixel_Step3 = round(focusZPixel_Step3);
fprintf('Distance between my guess and user: %d[pixels]\n',abs(focusZPixel_Step3-focusZPixel_Step2));

% Update main figure
subplot(1,4,[1 3])
hold on
plot(dim.x.values([1 end]),dim.z.values(focusZPixel_Step3)*[1 1],'--','Color',[0.9 0.8 0.2],'LineWidth',2);
legend('First Guess','Updated Guess','User Input');
hold off;

% Update average figure
subplot(1,4,4);
hold on
plot(dim.x.values([1 end]),dim.z.values(focusZPixel_Step3)*[1 1],'--','Color',[0.9 0.8 0.2],'LineWidth',2);
hold off;

% Allow figure to update to show the result
pause(0.1);

if (verbose)
    fprintf('User input: %d[pix]\n',focusZPixel_Step3);
end

zFocusPix = focusZPixel_Step3;